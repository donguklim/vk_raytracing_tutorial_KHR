/*
 * Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-FileCopyrightText: Copyright (c) 2019-2021 NVIDIA CORPORATION
 * SPDX-License-Identifier: Apache-2.0
 */

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require


#include "gltf.glsl"
#include "raycommon.glsl"
#include "sampling.glsl"
#include "host_device.h"

hitAttributeEXT vec3 beamHit;

// clang-format off
layout(location = 0) rayPayloadInEXT hitPayload prd;

layout(std430, set = 0, binding = 2) readonly buffer PhotonBeams{

    uint subBeamCount;
    uint beamCount;
    uint _padding_beams[2];
	PhotonBeam beams[];
};

layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };
// clang-format on

// Henyey-Greenstein phase function
float phaseFunc(float beamRayCos)
{
    // assymetriy factor
    // this value must be between -1 to 1
    // 0 value gives uniform phase function
    // value > 0 gives light out-scattering forward
    // value < 0 gives light out-scattering backward
    float assy = 0.0;

    return (1 - assy * assy) / ( 4 * M_PI * pow(1.0 + assy * assy - 2.0 * assy * beamRayCos,1.5));
}

void main()
{

    PhotonBeam beam = beams[gl_InstanceCustomIndexEXT];
    vec3 worldPos = gl_WorldRayOriginEXT + gl_WorldRayDirectionEXT * gl_HitTEXT;
    float beamDist = length(beamHit - beam.startPos);
    vec3 beamDirection = normalize(beamHit - beam.startPos);
    float rayDist = gl_HitTEXT;
    vec3 scatterCoff = vec3(log(1.0/0.10));
    vec3 extinctCoff = vec3(log(1.0/0.95));

    float beamRayCosVal = dot(gl_WorldRayDirectionEXT, beamDirection);
    float beamRayAbsSinVal = sqrt(1 - beamRayCosVal * beamRayCosVal);

    vec3 attenuation;
    attenuation.x = exp(-extinctCoff.x * (rayDist + beamDist));
    attenuation.y = exp(-extinctCoff.y * (rayDist + beamDist));
    attenuation.z = exp(-extinctCoff.z * (rayDist + beamDist));
    vec3 radiance = phaseFunc(beamRayCosVal) * scatterCoff * beam.lightColor * attenuation * scatterCoff / (pcRay.beamRadius * beamRayAbsSinVal + 0.1e-20);

    prd.hitValue += radiance;
    ignoreIntersectionEXT;
}