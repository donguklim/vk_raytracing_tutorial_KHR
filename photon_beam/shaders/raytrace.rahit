/*
 * Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-FileCopyrightText: Copyright (c) 2019-2021 NVIDIA CORPORATION
 * SPDX-License-Identifier: Apache-2.0
 */

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require


#include "gltf.glsl"
#include "raycommon.glsl"
#include "sampling.glsl"
#include "host_device.h"

hitAttributeEXT vec3 beamHit;

// clang-format off
layout(location = 0) rayPayloadInEXT hitPayload prd;

layout(std430, set = 0, binding = 2) readonly buffer PhotonBeams{

    uint subBeamCount;
    uint beamCount;
    uint _padding_beams[2];
	PhotonBeam beams[];
};

layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };
// clang-format on


// Henyey-Greenstein phase function
float phaseFunc(float cosTheta)
{
    // assymetriy factor
    // this value must be between -1 to 1
    // 0 value gives uniform phase function
    // value > 0 gives light out-scattering forward
    // value < 0 gives light out-scattering backward
    float g = 0.0;
    float denom = 1 + g * g + 2 * g * cosTheta;

    return (1 - g * g) / (denom * sqrt(denom))  / (4 * M_PI);

}

void main()
{

    PhotonBeam beam = beams[gl_InstanceCustomIndexEXT];
    vec3 worldPos = gl_WorldRayOriginEXT + gl_WorldRayDirectionEXT * gl_HitTEXT;
    float beamDist = length(beamHit - beam.startPos);
    vec3 beamDirection = normalize(beam.endPos - beam.startPos);
    float rayDist = gl_HitTEXT;
    vec3 vewingDirection = normalize(gl_WorldRayDirectionEXT) * -1.0;
 
    vec3 extinctCoff = pcRay.airExtinctCoff;
    vec3 scatterCoff = pcRay.airScatterCoff; 

    // the target radiance direction is -1.0 * gl_WorldRayDirectionEXT, opposite of the camera ray
    float beamRayCosVal = dot(-gl_WorldRayDirectionEXT, beamDirection);
    float beamRayAbsSinVal = sqrt(1 - beamRayCosVal * beamRayCosVal);
 
    vec3 attenuation;
    attenuation.x = exp(-extinctCoff.x * (rayDist + beamDist));
    attenuation.y = exp(-extinctCoff.y * (rayDist + beamDist));
    attenuation.z = exp(-extinctCoff.z * (rayDist + beamDist));
    vec3 radiance = phaseFunc(beamRayCosVal) * scatterCoff * beam.lightColor * attenuation / (pcRay.beamRadius * beamRayAbsSinVal + 0.1e-10);

    float rayBeamDist = length(worldPos - beamHit);
    //prd.hitValue += radiance * exp(-rayBeamDist);

    prd.hitValue += radiance;

    ignoreIntersectionEXT;
}