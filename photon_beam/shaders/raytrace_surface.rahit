/*
 * Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-FileCopyrightText: Copyright (c) 2019-2021 NVIDIA CORPORATION
 * SPDX-License-Identifier: Apache-2.0
 */

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#extension GL_EXT_debug_printf : require


#include "gltf.glsl"
#include "raycommon.glsl"
#include "sampling.glsl"
#include "host_device.h"

hitAttributeEXT vec3 beamHit;

// clang-format off
layout(location = 0) rayPayloadInEXT rayHitPayload prd;

layout(std430, set = 0, binding = 2) readonly buffer PhotonBeams{

    uint subBeamCount;
    uint beamCount;
    uint _padding_beams[2];
	PhotonBeam beams[];
};

layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };
// clang-format on


void main()
{

    PhotonBeam beam = beams[gl_InstanceCustomIndexEXT];

    if (prd.instanceIndex != beam.hitInstanceIndex)
    {
        ignoreIntersectionEXT;
        return;
    }

    vec3 worldPos = gl_WorldRayOriginEXT + gl_WorldRayDirectionEXT * gl_HitTEXT;
    vec3 towardLightDirection = normalize(beam.startPos - beam.endPos);
    float beamDist = length(beam.startPos - beam.endPos);
    float rayDist = gl_HitTEXT;
    vec3 vewingDirection = normalize(gl_WorldRayDirectionEXT) * -1.0;
 
    vec3 extinctCoff = pcRay.airExtinctCoff;

    // gltf BDRF
    // both light and viewDir are supposed start from the shading location
    float       aValSq    = pow(prd.hitRoughness, 4.0);
    vec3        halfVec   = normalize(towardLightDirection + vewingDirection);
    float       nDotH     = dot(prd.hitNormal, halfVec);
    float       nDotL     = dot(prd.hitNormal, towardLightDirection);
    float       vDotH     = dot(vewingDirection, halfVec);
    float       hDotL     = dot(towardLightDirection, halfVec);
    float       vDotN     = dot(vewingDirection, prd.hitNormal);

    vec3       c_diff = (1.0 - prd.hitMetallic) * prd.hitAlbedo;
    vec3       f0     = 0.04 * (1 - prd.hitMetallic) + prd.hitAlbedo * prd.hitMetallic;
    vec3       frsnel    = f0 + (1 - f0) * pow(1 - abs(vDotH), 5);
    vec3 f_diffuse = (1.0 - frsnel) / M_PI * c_diff;

    float dVal = 0.0;

    if (nDotH > 0) {
        float denom = (nDotH * nDotH * (aValSq - 1.0) + 1);
        denom       = denom * denom * M_PI;
        dVal        = aValSq / denom;
    }

    float gVal = 0.0;

    if(hDotL > 0 && vDotH > 0){
        float denom1 = sqrt(aValSq + (1 - aValSq) * nDotL * nDotL); 
        denom1 += abs(nDotL);

        float denom2 = sqrt(aValSq + (1 - aValSq) * vDotN * vDotN); 
        denom2 += abs(vDotN);

        gVal = 1.0 / (denom1 * denom2);

    }

    vec3 f_specular = frsnel * dVal * gVal;
    vec3 material_f = f_specular + f_diffuse;

    
 
    vec3 attenuation;
    attenuation.x = exp(-extinctCoff.x * (rayDist + beamDist));
    attenuation.y = exp(-extinctCoff.y * (rayDist + beamDist));
    attenuation.z = exp(-extinctCoff.z * (rayDist + beamDist));
    vec3 radiance = attenuation * material_f * beam.lightColor / (pcRay.photonRadius * pcRay.photonRadius * M_PI);

    float pointDist = length(worldPos - beam.endPos);
    //prd.hitValue += radiance * exp(-pcRay.photonRadius * pointDist * pointDist);

    //prd.hitValue += radiance * (1 - pointDist / pcRay.photonRadius);
    prd.hitValue += radiance;

    ignoreIntersectionEXT;
}