
#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require


#include "gltf.glsl"
#include "raycommon.glsl"
#include "sampling.glsl"
#include "host_device.h"

hitAttributeEXT vec2 attribs;

// clang-format off
layout(location = 0) rayPayloadInEXT hitPayload prd;
layout(location = 1) rayPayloadEXT bool isShadowed;

layout(std430, set = 0, binding = 2) readonly buffer PhotonBeams{

    uint subBeamCount;
    uint beamCount;
    uint _padding_beams[2];
	PhotonBeam beams[];
};


layout(buffer_reference, scalar) readonly buffer Vertices  { vec3  v[]; };
layout(buffer_reference, scalar) readonly buffer Indices   { ivec3 i[]; };

layout(set = 1, binding = eSceneDesc ) readonly buffer SceneDesc_ { SceneDesc sceneDesc; };

layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };
// clang-format on


void main()
{

  Ray ray;
  ray.origin    = gl_WorldRayOriginEXT;
  ray.direction = gl_WorldRayDirectionEXT;
  const vec3 rayEnd = ray.origin + ray.direction * gl_RayTmaxEXT;

  PhotonBeam beam = beams[gl_InstanceCustomIndexEXT];

  Vertices  vertices  = Vertices(sceneDesc.beamBoxVertexAddress);
  Indices   indices   = Indices(sceneDesc.beamBoxIndexAddress);

  ivec3 triangleIndex = indices.i[gl_PrimitiveID];

  const vec3 barycentrics = vec3(1.0 - attribs.x - attribs.y, attribs.x, attribs.y);

  const vec3 pos0           = vertices.v[triangleIndex.x];
  const vec3 pos1           = vertices.v[triangleIndex.y];
  const vec3 pos2           = vertices.v[triangleIndex.z];
  const vec3 position       = pos0 * barycentrics.x + pos1 * barycentrics.y + pos2 * barycentrics.z;
  const vec3 world_position = vec3(gl_ObjectToWorldEXT * vec4(position, 1.0));

  vec3 beamDirection = normalize(beam.endPos - beam.startPos);
  vec3 beamLength = length(beam.endPos - beam.startPos);
  const vec3 rayBeamCross = cross(ray.direction, beamDirection);
  vec3 norm1 = cross(ray.direction, rayBeamCross);
  vec3 norm2 = cross(beamDirection, rayBeamCross); 

  vec3 rayPoint = ray.origin + dot(beam.startPos - ray.orign, norm2) / dot(ray.direction, norm2) * ray.direction;

  vec3 beamPoint = beam.startPos + dot(ray.origin - beam.startPos, norm1) / dot(beamDirection, norm1) * beamDirection;

  vec3 rayPointLength = dot(rayPoint - ray.origin, ray.direction); 
  vec3 beamPointLength = dot(beamPoint - beam.startPos, beamDirection);
  
  if(rayPointLength < 0 && beamPointLength < 0){
    rayPoint = ray.origin;
    beamPoint = beam.startPos;
  }
  else if(rayPointLength > rayMaxLength && beamPointLength > beamLength) {
    rayPoint = rayEnd;
    beamPoint = beam.endPos;
  }
  else if((rayPointLength < 0 && beamPointLength > beamLength){
    rayPoint = ray.origin;
    beamPoint = beam.endPos;
  }
  else if(rayPointLength > rayMaxLength &&  beamPointLength < 0){
    rayPoint = rayEnd;
    beamPoint = beam.startPos;
  }
  else if(rayPointLength < 0){
    rayPoint = ray.origin;
    beamPoint = beam.startPos + beamDirection * dot(rayPoint - beamStartPos, beamDirection);
  }
  else if(rayPointLength > raymaxLength){
    rayPoint = rayEnd;
    beamPoint = beam.startPos + beamDirection * dot(rayPoint - beamStartPos, beamDirection);
  }
  else if(beamPointLength < 0){
    beamPoint = beam.startPos;
    rayPoint = ray.origin + ray.direction * dot(beamPoint - ray.origin, ray.direction);
  }
  else if(beamPointLength > beamLength){
    beamPoint = beam.endPos;
    rayPoint = ray.origin + ray.direction * dot(beamPoint - ray.origin, ray.direction);
  }

  if(length(beamPoint - rayPoint) <  pcRay.beamRadius)
    return;


  prd.hitValue = beam.lightColor;
}