
#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "gltf.glsl"
#include "raycommon.glsl"
#include "sampling.glsl"
#include "host_device.h"

hitAttributeEXT vec3 beamHit;

layout(std430, set = 0, binding = 2) readonly buffer PhotonBeams{

    uint subBeamCount;
    uint beamCount;
    uint _padding_beams[2];
	PhotonBeam beams[];
};

layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };
// clang-format on


void main()
{
    vec3 rayOrigin    = gl_WorldRayOriginEXT;
    vec3 rayDirection = gl_WorldRayDirectionEXT;
    const vec3 rayEnd = rayOrigin + rayDirection * gl_RayTmaxEXT;
    float rayLength = gl_RayTmaxEXT - 0.0001;

    PhotonBeam beam = beams[gl_InstanceCustomIndexEXT];

    vec3 beamDirection = normalize(beam.endPos - beam.startPos);
    float beamLength = length(beam.endPos - beam.startPos);
    const vec3 rayBeamCross = cross(rayDirection, beamDirection);

    //ray and beam are parallel
    // if ray touches beam cylinder
    // just picking  any closest point is okay. The attenuation value will be the same for any of the closest point pairs.
    if (length(rayBeamCross) < 0.1e-10)
    {
        float beamEndAt = dot(beam.endPos - rayOrigin, rayDirection);
        float beamStartAt = dot(beam.startPos - rayOrigin, rayDirection);
        
        // ray and beam segments do not overlap
        // then ray does not touch beam cylinder
        if (beamEndAt > rayLength && beamStartAt > rayLength)
        {
           return;
        }

        vec3 rayPoint;
        float rayPointAt;
        vec3 beamPoint;

        // ray and beam segments overlap, pick beam start position or end position as the closest point
        if (beamEndAt <= rayLength)
        {   
            rayPointAt = beamEndAt;
            beamPoint = beam.endPos;
            beamHit = beam.endPos;

        }
        else
        {
            rayPointAt = beamStartAt;
            beamPoint = beam.startPos;
        }

        if(length(beamPoint - rayPoint) >  pcRay.beamRadius)
        {
            return;
        }

        beamHit = beamPoint;
        rayPointAt = length(rayPoint - rayOrigin);
        reportIntersectionEXT(rayPointAt, 0);
        return;
    }

    vec3 norm1 = cross(rayDirection, rayBeamCross);
    vec3 norm2 = cross(beamDirection, rayBeamCross); 

    // get the nearest points between camera ray and beam
    vec3 rayPoint = rayOrigin + dot(beam.startPos - rayOrigin, norm2) / dot(rayDirection, norm2) * rayDirection;
    vec3 beamPoint = beam.startPos + dot(rayOrigin - beam.startPos, norm1) / dot(beamDirection, norm1) * beamDirection;

    float rayPointAt = dot(rayPoint - rayOrigin, rayDirection); 
    float beamPointAt = dot(beamPoint - beam.startPos, beamDirection);

    if(beamPointAt < 0)
    {
        beamPoint = beam.startPos;
    }
    else if(beamPointAt > beamLength)
    {
        beamPoint = beam.endPos;
    }
  
    if(rayPointAt < 0)
    {
        rayPoint = rayOrigin;
    }
    else if(rayPointAt > rayLength)
    {
        rayPoint = rayEnd;
    }

    if (beamPointAt < 0 || beamLength < beamPointAt)
    {
        rayPoint = rayOrigin + min(max(0.0f, dot(rayDirection, beamPoint - rayOrigin)), rayLength);
    }

    if(rayPointAt < 0 || rayLength < rayPointAt)
    {
        beamPoint = beam.startPos + min(max(0.0f, dot(beamDirection, rayPoint - beam.startPos)), beamLength);
    }

    // check if the raypoint projected at beam is within the beam line segment
    if(dot(beamDirection, rayPoint - beam.startPos) > beamLength)
    {
        return;
    }

    // check if ray point is within the beam radius
    if(length(beamPoint - rayPoint) >  pcRay.beamRadius)
    {
        return;
    }

    // Now check if ray is intersecting with this sub beam.
    float beamBoxStartAt = length(vec3(gl_ObjectToWorldEXT * vec4(0.0,0.0,0.0, 1.0)) - beam.startPos);
    beamPointAt = length(beamPoint - beam.startPos);

    if(beamPointAt < beamBoxStartAt || beamBoxStartAt + pcRay.beamRadius * 2 <= beamPointAt)
    {
        return;
    }

    beamHit = beamPoint;
    rayPointAt = length(rayPoint - rayOrigin);
    reportIntersectionEXT(rayPointAt, 0);
}
